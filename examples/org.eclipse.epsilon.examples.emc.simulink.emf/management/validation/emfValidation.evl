import "../util/emfUtil.eol";

context InPortBlock {
 	critique PropertyCheckB {  
		check {
			var prop = self.properties.selectOne(p|p.name == "PortDimensions");
			return (prop <> null) and (prop.value <> -1);
		} 
	}
}
context OutPortBlock { 
 	critique PropertyCheckC {
		check {
			var prop = self.properties.selectOne(p|p.name == "InputSignalNames");
			return (prop <> null) and (prop.value == self.simulinkRef.name);
		} 
	}
}
context SubSystem {
	
	critique TransitiveClosure { 
		check : self.closure(p|p.parent).flatten().size() < 2 
	}
	critique NavigationAndFilterA {
		guard : not InPortBlock.all.select(i | self.inports.includes(i)).isEmpty()
		check { 
			var inports = InPortBlock.all.select(i | self.inports.includes(i));
			var colorProperties = inports.properties.flatten().select(p|p.name == "ForegroundColor");
			return (not colorProperties.isEmpty()) and (colorProperties.forAll(c|(c <> null) and (c.value == "green")));
		}
	}
	critique NavigationAndFilterB { 
		check : self.ports.select(p|p.isTypeOf(OutPort)).collect(o|o.name).forAll(n|n <> null and n <> "") 
	}
}
context Block {  
	critique PropertyCheckA { 
		guard: self.isSum()
		check : self.properties.selectOne(p|p.name == "SaturateOnIntegerOverflow").value == "on" 
	}
	critique LoopAbsence { 
		guard: self.isGain()
		check : not self.getOutgoingSingleConnections().exists(c|c == self) 
	}
	critique VertexConnectivityA {  
		check {
			var connections = self.getOutgoingSingleConnections();
			if ((not connections.isEmpty()) and (connections.forAll(e|e <> null))){
				return connections.collect(c|c.to.container).forAll(c|c <> null);
			} 
			return false;
		}				
	}
}
operation Block getOutgoingSingleConnections() : Sequence {
	var result = new Sequence;
	var outports = self.ports.select(p|p.isTypeOf(OutPort));
	if (not outports.isEmpty()){
		var connection = outports.connection;
		for (c in connection){
			if (c.isTypeOf(MultiConnection)){
				result.addAll(c.connections);
			} else {
				result.add(c);
			}
		}
	}
	return result.flatten();
}